# Многопользовательский чат

Программный комплекс состоит из двух приложений: Чат-Сервер и Чат-Клиент. Функционал заключается
в общении нескольких пользователей **Клиента** посредством текстовых сообщений в консоли,
которое обеспечивается их подключением к общему **Серверу**.

Исходный код разделён на три пакета:
1. _common_ содержит описание протокола взаимодействия (классы _MessageType_ и _Message_)
и утилиты, необходимые для работы обоих приложений (классы _Configurator_, _Logger_ и _LogWriter_).
2. _server_ содержит классы **Сервера**: _Server_, _Dispatcher_ и _Connection_.
3. _client_ содержит классы **Клиента**: _Client_ и _Receiver_.

### Запуск приложений
**Сервер** запускается через метод `server.Server.main()`, **Клиент** запускается через метод
`client.Client.main()`. Предполагается работа нескольких пользователей клиентской части 
с разных машин. Для демонстрационной работы программы в IntelliJ IDEA для каждого клиента
создаётся отдельная конфигурация запуска.

Параметры запуска **Сервера** и **Клиента** загружаются из конфигурационных файлов:
в начале исполнения их методов `main()` создаётся экземпляр соответствующего класса на
основе значений, полученных из указанного файла. Формат файла настроек см. в разделе про **Конфигуратор**.

Для **Сервера** в данной реализации используется только файл настроек по умолчанию: _settings.ini_,
ссылка на него хранится в статической константе. Если в файле отсутствуют какие-либо настройки,
они восполняются значениями по умолчанию.

Для **Клиента** основным способом задания файла настроек является его указание в качестве
аргумента методу `main()` в командной строке или в соответствующей строке конфигурации
запуска в IDEA. Данная реализация содержит два тестовых файла: _client_1.ini_ и _client_2.ini_.
В случае запуска **Клиента** без аргумента, или если переданный аргумент не является именем
существующего файла, приложение будет предлагать указать его вручную, пока не будет получено
имя доступного файла. Если указанный файл таки не окажется корректным для приложения файлом
настроек, все параметры будут заполнены по умолчанию. Также по умолчанию будут выставлены
все настройки, которые не будут найдены в файле.

## Протокол взаимодействия и формат сообщений
Взаимодействие **Клиентов** и **Сервера** осуществляется посредством обмена **Сообщениями**
(объектами класса _Message_) через устанавливаемые **Клиентами** до **Сервера** сокетные http-соединения.

### Описание класса **Сообщение**
##### Поля
Сериализуемый класс _Message_ содержит четыре поля:
* `final private MessageType type` = **Тип Сообщения**, определяющий алгоритм его обработки при получении
(описание типов см. ниже).
* `final private String sender` = отправитель **Сообщения**: для **Клиента** - текущее имя пользователя;
для **Серверных Сообщений** - `null`, либо, если это условный сигнал на завершение соединения,
пустая строка (`""`).
* `private String addressee` = адресат **Сообщения**: для публичных сообщений от Чат-Клиента
(то есть адресованных всем подключённым участникам беседы) и сообщений-запросов - `null`,
для персональных сообщений определённому пользователю - зарегистрированное на Чат-Сервере
имя получателя; Чат-Сервер в **Серверном Сообщении** заполняет это поле `null`, пока 
пользователь не зарегистрирован в **Диспетчере** - после же когда регистрация состоялась,
получатель должен быть явно указан, поэтому присутствует метод `.setAdressee(String имя_получателя)` 
для выставления адресатов, когда одинаковое **Серверное Сообщение** рассылается всем 
подключённым пользователям. По значению этого поля в **Серверном Сообщении** Чат-Клиент определяет, 
что запрошенное (при регистрации либо по ходу беседы) имя принято и зарегистрировано на Чат-Сервере.
* `final private String message` = собственно текст сообщения; в сообщениях-запросах
(т.е. кроме Серверных, Публичных и Персональных) - `null`.
##### Методы
Кроме методов доступа к полям, класс _Message_ предоставляет статические методы для создания
экземпляров:
* `public static Message fromClientInput(String inputText, String sender)`
* `public static Message fromServer(String messageText, String receiver)`
* `public static Message fromServer(String messageText)`
* `public static Message registering(String putName)`
* `public static Message stopSign(String recipient)` (@Deprecated ?)

А также вспомогательные методы:
* `public static boolean isAcceptableName(String name)`
* `public boolean isStopSign()`

Метод `.toString()` используется для представления **Сообщения** в консоли. Для **Серверных**
и **Персональных** сообщений в первой строке выводится указание типа сообщения,
для сообщений-запросов условное обозначение типа. Затем, в следующей строке (или в первой для 
**Публичных Сообщений**), если указан (не `null`) отправитель, "имя_отправителя > " + текст сообщения.

### Типы сообщений
Всё взаимодействие обеспечивается с помощью семи **Типов Сообщения**, перечисленных в классе _MessageType_:
1. `SERVER_MSG` = **Серверное Сообщение**, т.е. информационное сообщение от Чат-Сервера.
2. `TXT_MSG` = **Публичное Сообщение**, т.е. обычное сообщение, посылаемое пользователем Чат-Клиента
и затем рассылаемое Чат-Сервером всем подключённым участникам беседы, кроме отправителя.
3. `PRIVATE_MSG` = **Частное Сообщение**, посылаемое пользователем Чат-Клиента и затем пересылаемое
Чат-Сервером указанному в качестве получателя участнику, если таковой подключён.
4. `REG_REQUEST` = запрос на регистрацию от пользователя.
5. `LIST_REQUEST` = запрос от клиента на получение списка подключённых пользователей.
6. `EXIT_REQUEST` = запрос от клиента на выход из чата.
7. `SHUT_REQUEST` = запрос от клиента на остановку работы сервера. В данной реализации это
единственный корректный способ остановить Чат-Сервер.