# Многопользовательский чат

Программный комплекс состоит из двух приложений: Чат-Сервер и Чат-Клиент. Функционал заключается
в общении нескольких пользователей **Клиента** посредством текстовых сообщений в консоли,
которое обеспечивается их подключением к общему **Серверу**.

Исходный код разделён на три пакета:
1. _common_ содержит описание протокола взаимодействия (классы _MessageType_ и _Message_)
и утилиты, необходимые для работы обоих приложений (классы _Configurator_, _Logger_ и _LogWriter_).
2. _server_ содержит классы **Сервера**: _Server_, _Dispatcher_ и _Connection_.
3. _client_ содержит классы **Клиента**: _Client_ и _Receiver_.

### Запуск приложений
**Сервер** запускается через метод `server.Server.main()`, **Клиент** запускается через метод
`client.Client.main()`. Предполагается работа нескольких пользователей клиентской части 
с разных машин. Для демонстрационной работы программы в IntelliJ IDEA для каждого клиента
создаётся отдельная конфигурация запуска.

Параметры запуска сервера и клиента загружаются из конфигурационных файлов:
в начале исполнения их методов `main()` создаётся экземпляр соответствующего класса на
основе значений, полученных из указанного файла. Формат файла настроек см. в разделе про **Конфигуратор**.

Для **Сервера** в данной реализации используется только файл настроек по умолчанию: _settings.ini_,
ссылка на него хранится в статической константе. Если в файле отсутствуют какие-либо настройки,
они восполняются значениями по умолчанию.

Для **Клиента** основным способом задания файла настроек является его указание в качестве
аргумента методу `main()` в командной строке или в соответствующей строке конфигурации
запуска в IDEA. Данная реализация содержит два тестовых файла: _client_1.ini_ и _client_2.ini_.
В случае запуска **Клиента** без аргумента, или если переданный аргумент не является именем
существующего файла, приложение будет предлагать указать его вручную, пока не будет получено
имя доступного файла. Если указанный файл таки не окажется корректным для приложения файлом
настроек, все параметры будут заполнены по умолчанию. Также по умолчанию будут выставлены
все настройки, которые не будут найдены в файле.

## Протокол взаимодействия и формат сообщений
Взаимодействие **Клиентов** и **Сервера** осуществляется посредством обмена **Сообщениями**
(объектами класса _Message_) через устанавливаемые Клиентами до Сервера** сокетные http-соединения.

### Описание класса **Сообщение**
##### Поля́
Сериализуемый класс _Message_ содержит четыре по́ля:
* `final private MessageType type` = **Тип Сообщения**, определяющий алгоритм его обработки при получении
(описание типов см. ниже).
* `final private String sender` = отправитель сообщения: для порождаемых Клиентом – текущее имя пользователя;
для серверных сообщений - `null`, либо, если это условный сигнал на завершение соединения,
пустая строка (`""`).
* `private String addressee` = адресат сообщения: для публичных сообщений от Чат-Клиента
(то есть адресованных всем подключённым участникам беседы) и сообщений-запросов – `null`,
для персональных сообщений определённому пользователю – зарегистрированное на Чат-Сервере
имя получателя. Чат-Сервер в серверном сообщении заполняет это поле `null`, пока 
пользователь не зарегистрирован в **Диспетчере** – после же когда регистрация состоялась,
получатель должен быть явно указан, поэтому присутствует метод `.setAdressee(String имя_получателя)` 
для выставления адресатов, когда одинаковое серверное сообщение рассылается всем 
подключённым пользователям. По значению этого поля в серверном сообщении Чат-Клиент определяет, 
что запрошенное (при регистрации либо по ходу беседы) имя принято и зарегистрировано на Чат-Сервере.
* `final private String message` = собственно текст сообщения; в сообщениях-запросах
(т.е. кроме серверных, публичных и персональных) - `null`.
##### Методы
Кроме методов доступа к полям, класс _Message_ предоставляет статические методы для создания
экземпляров (открытого конструктора в классе нет):
* `public static Message fromClientInput(String inputText, String sender)` Создаёт на клиентской
стороне экземпляр сообщения на основе пользовательского ввода и указанного имени отправителя 
(берётся из имени пользователя).
* `public static Message fromServer(String messageText, String receiver)` Создаёт на серверной стороне
серверное сообщение с указанным текстом, адресованное указанному получателю.
* `public static Message fromServer(String messageText)` Создаёт на сервере серверное сообщение с указанным
текстом без указания получателя (предполагается, что получатели будут выставлены отдельно).
* `public static Message registering(String putName)` Создаёт на клиентской стороне сообщение с запросом 
регистрации указанного имени.
* `public static Message stopSign(String recipient)` (@Deprecated ?)

А также вспомогательные методы:
* `public static boolean isAcceptableName(String name)` Инструментальная функция, проверяющая, является ли
строка допустимой в качестве регистрируемого имени пользователя. В настоящей реализации используется проверка
соответствия регулярному выражению `"[\\p{L}]+\\d*\\s*"`.
* `public boolean isStopSign()` Вспомогательный показатель, является ли сообщение сигналом о завершении.

Метод `.toString()` используется для представления **Сообщения** в консоли. Основной шаблон
включает _имя отправителя_ + " > " (если отправитель не `null`) + _текст сообщения_ (если оно не `null`).
Для типов кроме публичного этот шаблон предваряется отдельной строкой с явным описанием типа для личных
и серверных или с условным обозначением типа для сообщений-запросов.

### Типы сообщений
Всё взаимодействие обеспечивается с помощью семи **Типов Сообщения**, перечисленных в классе _MessageType_:
1. `SERVER_MSG` = **Серверное Сообщение**, т.е. информационное сообщение от Чат-Сервера.
2. `TXT_MSG` = **Публичное Сообщение**, т.е. обычное сообщение, посылаемое пользователем Чат-Клиента
и затем рассылаемое Чат-Сервером всем подключённым участникам беседы, кроме отправителя.
3. `PRIVATE_MSG` = **Частное Сообщение**, посылаемое пользователем Чат-Клиента и затем пересылаемое
Чат-Сервером указанному в качестве получателя участнику, если таковой подключён.
4. `REG_REQUEST` = запрос на регистрацию от пользователя.
5. `LIST_REQUEST` = запрос от клиента на получение списка подключённых пользователей.
6. `EXIT_REQUEST` = запрос от клиента на выход из чата.
7. `SHUT_REQUEST` = запрос от клиента на остановку работы сервера. В данной реализации это
единственный корректный способ остановить Чат-Сервер.

В реализации используется обращение к элементам перечисления по `.ordinal()`, это требует внимания 
при внесении изменений в типы сообщения.

## Работа серверной части
### Архитектура
Серверная часть состоит из следующих компонентов:
* класс _Server_ – **Сервер** слушает за входящие на серверный порт подключения.
* класс _Connection_ – **Соединение** обслуживает обмен сообщениями с конкретным подключённым клиентом.
* класс _Dispatcher_ – **Диспетчер** хранит карту соответствий зарегистрированных имён и соединений,
осуществляет направление сообщений между участниками общения и обработку сообщений-запросов.

По инициализации, **Сервер** создаёт в себе новые **Диспетчер** и **Логировщик** и
начинает слушать входящие подключения на порту, указанном в поле `server.Server.PORT`.
Обнаружив подключение и установив сокетное соединение с клиентом, он создаёт и запускает в обойме потоков
новый объект класса **Соединение**, передавая в него только что полученный сокет и ссылку на себя.

Соединение начинает работать с подключённым клиентом, сперва запуская процедуру регистрации
